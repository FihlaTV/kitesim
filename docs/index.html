<!DOCTYPE html>
<html>
<head>
  <title>KiteX kite simulator</title>
  <!-- <script type="text/javascript" src="./js/svg.js"></script> -->
  <script src="./js/three.js"></script>
  <script src="./js/threeJSOrbitControl.js"></script>
  <script src="./js/key.js"></script>
  <script src="./js/aeroData.js"></script>
  <script src="./js/aeroSurface.js"></script>
  <script src="./js/plane.js"></script>
  <script src="./js/tether.js"></script>


  <style>
    body { margin: 0; }
    canvas { width: 100%; height: 100% }

    #info {
    	position: absolute;
    	top: 10px;
    	width: 100%;
    	text-align: left;
    	z-index: 100;
    	display:block;
      color: white;
    }

  </style>
</head>
<body>
  <div id="info">Description</div>
  <!-- <div id="drawing"></div> -->
  <!-- <script type="text/javascript" src="./js/main.js"></script> -->
  <script>

    window.addEventListener('keydown', function(e) { Key.onKeydown(e) })
    window.addEventListener('keyup', function(e) { Key.onKeyup(e) })

    // user input
    var rotationRate = Math.PI // rad / s
    var thrustRate = 20 // N / s
    var thrustMax = new THREE.Vector3( 0, 0, -35) // N
    var thrustMin = new THREE.Vector3( 0, 0, 0) // N
    var thrust = new THREE.Vector3( 0, 0, -25) // in the frame of the kite


    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

    // controls
    controls = new THREE.OrbitControls(camera);
    controls.rotateSpeed = 1.0;
    controls.zoomSpeed = 1.2;
    controls.panSpeed = 0.8;

    // camera
    camera.position.x = -6;
    camera.position.y = 6;
    camera.position.z = 6;
    camera.lookAt(new THREE.Vector3( 0, 5, 0 ))

    function setupLights() {
      // LIGHTS
      hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 )
      hemiLight.color.setHSL( 0.6, 1, 0.6 )
      hemiLight.groundColor.setHSL( 0.095, 1, 0.75 )
      hemiLight.position.set( 0, 500, 0 )
      scene.add( hemiLight )
      //
      dirLight = new THREE.DirectionalLight( 0xffffff, 1 )
      dirLight.color.setHSL( 0.1, 1, 0.95 )
      dirLight.position.set( 20, 100, 0 )
      dirLight.position.multiplyScalar( 50 )
      scene.add( dirLight )
    }
    setupLights()

    // Helpers
    axes = new THREE.AxisHelper(10)
    helper = new THREE.GridHelper(100, 100)
    // helper.geometry.rotateX( Math.PI / 2 );
    helper.setColors(0x0000ff, 0x808080)
    scene.add(axes)
    scene.add(helper)


    var kite = new Kite(kiProp)

    kite.obj.add(new THREE.AxisHelper(10))
    kite.obj.rotateX(Math.PI / 2 )

    var renderer = new THREE.WebGLRenderer()
    renderer.setSize( window.innerWidth, window.innerHeight )
    document.body.appendChild( renderer.domElement )


    // Moment of Inertia kite
    var JkiteX = 0.15
    var JkiteY = 0.05
    var JkiteZ = 0.15

    var J = new THREE.Matrix3()
    // J.set( 11, 12, 13,
    //        21, 22, 23,
    //        31, 32, 33 );
    J.set( JkiteX, 0, 0,
          0, JkiteY, 0,
          0, 0, JkiteZ );

    var Jinv = new THREE.Matrix3().getInverse ( J, function() {
      alert('No Inverse')
    } )
    var angularVelocityKite = new THREE.Vector3( 0, 0, 0 )
    var velocityKite = new THREE.Vector3( 0, 0, 0)

    // helper arrows


    // function addHelperArrows() {
      var dir = new THREE.Vector3( 1, 0, 0 );
      var origin = new THREE.Vector3( 0, 0, 0 );
      var length = 1;
      var hex = 0xffff00;

      var arrowHelperElevator = new THREE.ArrowHelper( dir, kite.elevatorPosition, length, 0x0000ff )
      var arrowHelperRudder = new THREE.ArrowHelper( dir, kite.rudderPosition, length, 0x00ffff )
      var arrowHelperTAP1 = new THREE.ArrowHelper( dir, kite.tetherAttachmentPoint1, length, 0xff00ff )
      var arrowHelperTAP2 = new THREE.ArrowHelper( dir, kite.tetherAttachmentPoint2, length, 0x0000ff )

      kite.obj.add( arrowHelperElevator )
      kite.obj.add( arrowHelperRudder )
      kite.obj.add( arrowHelperTAP1 )
      kite.obj.add( arrowHelperTAP2 )

      // var arrowHelperLift = new THREE.ArrowHelper( dir, origin, length, 0xffff00 )
      // var arrowHelperDrag = new THREE.ArrowHelper( dir, origin, length, 0xff0000 )
      // var arrowHelperLiftSide = new THREE.ArrowHelper( dir, origin, length, 0xff5500 )
      // var arrowHelperDragSide = new THREE.ArrowHelper( dir, origin, length, 0xff0000 )

      // kite.obj.add( arrowHelperLift )
      // kite.obj.add( arrowHelperDrag )
      // kite.obj.add( arrowHelperLiftSide )
      // kite.obj.add( arrowHelperDragSide )
    // }
    //
    // addHelperArrows()

    // Constants
    const rho = 1.205
    const wind = new THREE.Vector3( 10, 0, 0)
    const gravity = new THREE.Vector3( 0, -9.82, 0)


    var massKite = 1.5

    var teProp = {
      segments : 10,
      totalLength : 70,
      kiteTLength : 3, // meter
      density : 950,
      diameter : 0.002,
      k0 : 2000, // spring konstant // N per e,
      k0_negative : 0, // spring konstant // N per e,
      d0 : 1, // damping,
      cd : 0.95,
    }

    // kite
    var dx = Math.sqrt(teProp.kiteTLength*teProp.kiteTLength-kite.tetherAttachmentPoint1.y*kite.tetherAttachmentPoint1.y)
    kite.obj.position.add( new THREE.Vector3(teProp.totalLength + dx, 0, 0) )
    scene.add(kite.obj)

    var mTether = new Tether(kite)


    function detectUserInput(dt) {
      // var a = THREE.Vector3(0, 0, -thrustRate * dt)
      // user input
      if (Key.isDown(Key.UP)) kite.elevator.rotateZ(-rotationRate * dt)
      if (Key.isDown(Key.LEFT)) kite.rudder.rotateZ(-rotationRate * dt)
      // if (Key.isDown(Key.DOWN)) kite.obj.rotateY(rotationRate * dt)
      if (Key.isDown(Key.DOWN)) kite.elevator.rotateZ(rotationRate * dt)
      if (Key.isDown(Key.RIGHT)) kite.rudder.rotateZ(rotationRate * dt)
      if (Key.isDown(Key.S)) kite.obj.rotateZ(-rotationRate/4 * dt)
      if (Key.isDown(Key.X)) kite.obj.rotateZ(rotationRate/4 * dt)
      if (Key.isDown(Key.A)) thrust.add( new THREE.Vector3(0, 0, -thrustRate * dt) ).max(thrustMax).min(thrustMin)
      if (Key.isDown(Key.Z)) thrust.add( new THREE.Vector3(0, 0, thrustRate * dt) ).max(thrustMax).min(thrustMin)
    }


    var wingAero = new AeroSurface(kite.wing, kiProp.wing.area, false,
      function(v) { return new THREE.Vector3( v.z, 0, -v.x ) },
      function(v) { return new THREE.Vector3( v.x, 0,  v.z ) }
    )

    var vWingAero = new AeroSurface( kite.vWing, kiProp.vWing.area, false,
      function(v) { return new THREE.Vector3( 0, v.z, -v.y ) },
      function(v) { return new THREE.Vector3( 0, v.y,  v.z ) }
    )

    var elevatorAero = new RotatingAeroSurface( kite.elevator, kiProp.elevator.area, true, kite.elevatorPosition,
      function(v) { return new THREE.Vector3( v.z, 0, -v.x ) },
      function(v) { return new THREE.Vector3( v.x, 0,  v.z ) }
    )

    var rudderAero = new RotatingAeroSurface( kite.rudder, kiProp.rudder.area, true, kite.rudderPosition,
      function(v) { return new THREE.Vector3( 0, v.z, -v.y ) },
      function(v) { return new THREE.Vector3( 0, v.y,  v.z ) }
    )

    var apKiteWorld, tap1SpringForceKite, tap2SpringForceKite

    function updateKitePositionAndForces(dt, tether) {
      //
      // KITE AERODYNAMICS
      //

      var kiteTF = mTether.kiteTetherForces()

      apKiteWorld = wind.clone().sub(velocityKite)
      var apKiteKite = apKiteWorld.clone().applyQuaternion(kite.obj.getWorldQuaternion().conjugate())
      var thrustWorld = thrust.clone().applyQuaternion(kite.obj.getWorldQuaternion())

      wingAero.update(apKiteWorld, apKiteKite)
      vWingAero.update(apKiteWorld, apKiteKite)

      elevatorAero.update(apKiteWorld, apKiteKite, angularVelocityKite)
      rudderAero.update(apKiteWorld, apKiteKite, angularVelocityKite)

      // Total aero forces
      var aeroForcesKite = wingAero.lift.clone()
        .add(wingAero.drag)
        .add(vWingAero.lift)
        .add(vWingAero.drag)
        .add(elevatorAero.totalAero)
        .add(rudderAero.totalAero)

      // moments and rotation of kite
      tap1SpringForceKite = kiteTF.spring1.clone().applyQuaternion( kite.obj.quaternion.clone().conjugate() )
      tap2SpringForceKite = kiteTF.spring2.clone().applyQuaternion( kite.obj.quaternion.clone().conjugate() )

      var momentsKite = kite.elevatorPosition.clone().cross(elevatorAero.totalAero)
        .add(kite.rudderPosition.clone().cross(rudderAero.totalAero))
        .add(kite.tetherAttachmentPoint1.clone().cross( tap1SpringForceKite ) )
        .add(kite.tetherAttachmentPoint2.clone().cross( tap2SpringForceKite ) )

      var angularAcceleration = momentsKite.clone().applyMatrix3(Jinv)//.setComponent(0, 0).setComponent(1, 0)
      angularVelocityKite.add(angularAcceleration.multiplyScalar(dt))

      kite.obj.rotateOnAxis( angularVelocityKite.clone().normalize(), angularVelocityKite.length() * dt )

      // tether plus kite forces
      var FKite = kiteTF.spring1.clone()
        .add( kiteTF.spring2 )
        .add( kiteTF.drag1 )
        .add( kiteTF.drag2 )
        .add( thrustWorld )
        .add( aeroForcesKite.clone().applyQuaternion(kite.obj.quaternion))

      // update kite tether and position
      var accelerationKite = FKite.divideScalar(massKite + mTether.mass[mTether.KIndex1] + mTether.mass[mTether.KIndex2]).add(gravity)
      velocityKite.add(accelerationKite.multiplyScalar(dt))
      kite.obj.position.add(velocityKite.clone().multiplyScalar(dt))
    }


    function update(dt) {

      dt = dt // realtime
      dt = Math.min(dt, 0.03) // max timestep of 0.05 seconds

      detectUserInput(dt)

      var subFrameIterations = 20

      for (var k = 0; k < subFrameIterations; k++) {

        mTether.updateTetherPositionAndForces(dt/subFrameIterations)
        updateKitePositionAndForces(dt/subFrameIterations)

        mTether.updateKiteTetherPosAndVelocity(kite)
      }

      // UPDATE UI
      // Set the position of the boxes showing the tether.
      for (var i = 0; i <= mTether.indexEnd; i++) {
        mTether.renderObjects[i].position.set(mTether.pos[i].x, mTether.pos[i].y, mTether.pos[i].z)
      }

      // Extra UI updates

      // arrowHelperLift.setDirection( wingLift.clone().normalize() )
      // arrowHelperDrag.setDirection( wingDrag.clone().normalize() )
      // arrowHelperLiftSide.setDirection( vwingLift.clone().normalize() )
      // arrowHelperDragSide.setDirection( vwingDrag.clone().normalize() )
      //
      // arrowHelperDrag.setLength( wingDrag.length() )
      // arrowHelperLift.setLength( wingLift.length() )
      // arrowHelperDragSide.setLength( vwingDrag.length() )
      // arrowHelperLiftSide.setLength( vwingLift.length() )

      arrowHelperElevator.setDirection( elevatorAero.totalAero.clone().normalize() )
      arrowHelperElevator.setLength( elevatorAero.totalAero.length() )

      arrowHelperRudder.setDirection( rudderAero.totalAero.clone().normalize() )
      arrowHelperRudder.setLength( rudderAero.totalAero.length() )
      //
      arrowHelperTAP1.setDirection( tap1SpringForceKite.clone().normalize() )
      arrowHelperTAP1.setLength( tap1SpringForceKite.length() )

      arrowHelperTAP2.setDirection( tap2SpringForceKite.clone().normalize() )
      arrowHelperTAP2.setLength( tap2SpringForceKite.length() )


      document.getElementById('info').innerHTML = "apparent wind speed : " + apKiteWorld.length()
      document.getElementById('info').innerHTML = "alfa wing: " + Math.round(wingAero.alfa * 180 / Math.PI) + "<br />"
      document.getElementById('info').innerHTML += "alfa vertical wing : " + Math.round(vWingAero.alfa * 180 / Math.PI) + "<br />"
      document.getElementById('info').innerHTML += "thrust: " + thrust.getComponent(2) + "<br />"
      document.getElementById('info').innerHTML += "velocity: " + velocityKite.length(2) + "<br />"
      // document.getElementById('info').innerHTML += "spring1: " + FSpring[KTIndex1].x + "<br />"
      // document.getElementById('info').innerHTML += "spring2: " + FSpring[KTIndex2].x + "<br />"
      // document.getElementById('info').innerHTML += "tSegmentStretchVelocity: " + tSegmentStretchVelocity[1] + "<br />"

    }

    var lastTime, animFrame

    function render(ms) {
      // we get passed a timestamp in milliseconds
      // we use it to determine how much time has passed since the last call
      if (lastTime) {
        update((ms-lastTime)/1000) // call update and pass delta time in seconds
      }

      lastTime = ms
      animFrame = requestAnimationFrame(render)
      renderer.render( scene, camera );

    }

    render()
  </script>


</body>
</html>
