<!DOCTYPE html>
<html>
<head>
  <title>KiteX kite simulator</title>
  <!-- <script type="text/javascript" src="./js/svg.js"></script> -->
  <script src="./js/three.js"></script>
  <script src="./js/threeJSOrbitControl.js"></script>
  <script src="./js/key.js"></script>
  <script src="./js/aeroData.js"></script>
  <script src="./js/aeroSurface.js"></script>
  <script src="./js/plane.js"></script>
  <script src="./js/tether.js"></script>


  <style>
    body { margin: 0; }
    canvas { width: 100%; height: 100% }

    #info {
    	position: absolute;
    	top: 10px;
    	width: 100%;
    	text-align: left;
    	z-index: 100;
    	display:block;
      color: white;
    }

  </style>
</head>
<body>
  <div id="info">Description</div>
  <!-- <div id="drawing"></div> -->
  <!-- <script type="text/javascript" src="./js/main.js"></script> -->
  <script>

    window.addEventListener('keydown', function(e) { Key.onKeydown(e) })
    window.addEventListener('keyup', function(e) { Key.onKeyup(e) })

    // user input
    var rotationRate = Math.PI // rad / s
    var thrustRate = 20 // N / s
    var thrustMax = new THREE.Vector3( 0, 0, -35) // N
    var thrustMin = new THREE.Vector3( 0, 0, 0) // N
    var thrust = new THREE.Vector3( 0, 0, -25) // in the frame of the kite

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

    // controls
    controls = new THREE.OrbitControls(camera);
    controls.rotateSpeed = 1.0;
    controls.zoomSpeed = 1.2;
    controls.panSpeed = 0.8;

    // camera
    camera.position.x = -6;
    camera.position.y = 0;
    camera.position.z = 0;
    camera.lookAt(new THREE.Vector3( 0, 0, 0 ))

    function setupLights() {
      // LIGHTS
      hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 )
      hemiLight.color.setHSL( 0.6, 1, 0.6 )
      hemiLight.groundColor.setHSL( 0.095, 1, 0.75 )
      hemiLight.position.set( 0, 500, 0 )
      scene.add( hemiLight )
      //
      dirLight = new THREE.DirectionalLight( 0xffffff, 1 )
      dirLight.color.setHSL( 0.1, 1, 0.95 )
      dirLight.position.set( 20, 100, 0 )
      dirLight.position.multiplyScalar( 50 )
      scene.add( dirLight )
    }
    setupLights()

    // Helpers
    axes = new THREE.AxisHelper(10)
    helper = new THREE.GridHelper(25, 25)
    // helper.geometry.rotateX( Math.PI / 2 );
    helper.setColors(0x0000ff, 0x808080)
    scene.add(axes)
    scene.add(helper)

    var renderer = new THREE.WebGLRenderer()
    renderer.setSize( window.innerWidth, window.innerHeight )
    document.body.appendChild( renderer.domElement )

    // helper arrows

    // function addHelperArrows() {
      // var dir = new THREE.Vector3( 1, 0, 0 );
      // var origin = new THREE.Vector3( 0, 0, 0 );
      // var length = 1;
      // var hex = 0xffff00;

      // var arrowHelperElevator = new THREE.ArrowHelper( dir, kite.elevatorPosition, length, 0x0000ff )
      // var arrowHelperRudder = new THREE.ArrowHelper( dir, kite.rudderPosition, length, 0x00ffff )
      // var arrowHelperTAP1 = new THREE.ArrowHelper( dir, kite.tetherAttachmentPoint1, length, 0xff00ff )
      // var arrowHelperTAP2 = new THREE.ArrowHelper( dir, kite.tetherAttachmentPoint2, length, 0x0000ff )
      //
      // kite.obj.add( arrowHelperElevator )
      // kite.obj.add( arrowHelperRudder )
      // kite.obj.add( arrowHelperTAP1 )
      // kite.obj.add( arrowHelperTAP2 )

      // var arrowHelperLift = new THREE.ArrowHelper( dir, origin, length, 0xffff00 )
      // var arrowHelperDrag = new THREE.ArrowHelper( dir, origin, length, 0xff0000 )
      // var arrowHelperLiftSide = new THREE.ArrowHelper( dir, origin, length, 0xff5500 )
      // var arrowHelperDragSide = new THREE.ArrowHelper( dir, origin, length, 0xff0000 )

      // kite.obj.add( arrowHelperLift )
      // kite.obj.add( arrowHelperDrag )
      // kite.obj.add( arrowHelperLiftSide )
      // kite.obj.add( arrowHelperDragSide )
    // }
    //
    // addHelperArrows()

    var angleError, currentHeading, angleToPoint

    class PathFollow {
      constructor(headingAngle, altitudeAngle, radius, N, rudder) {
        this.index = Math.floor(N/2)
        this.lookAheadDistance = radius*0.9
        this.points = []
        this.N = N
        this.rudder = rudder
        this.on = false

        for (var i = 0; i < this.N; i++) {
          this.points.push( new THREE.Vector2( radius * Math.cos( -i/N*2*Math.PI ), radius * Math.sin( -i/N*2*Math.PI ) ) )
        }

        this.quaternion = new THREE.Quaternion().setFromEuler(
          new THREE.Euler(0 , headingAngle/180 * Math.PI, altitudeAngle/180 * Math.PI, 'YZX')
        )
        this.qConjugate = this.quaternion.clone().conjugate()

        var pointer = new THREE.ArrowHelper(
          new THREE.Vector3(1,0,0).applyQuaternion(this.quaternion),
          new THREE.Vector3(0,0,0),
          10,
          0xff0000 )

        scene.add(pointer)

        this.box = new THREE.Mesh(
          new THREE.BoxGeometry( 1, 1, 1 ),
          new THREE.MeshLambertMaterial( { color: 0xffff00 } )
          )
        scene.add(this.box)

        this.setUpListener()
      }

      update(position, velocity) {

        // move position in to local coordinate system
        var posLocal3D = position.applyQuaternion(this.qConjugate)
        var posLocal2D = new THREE.Vector2(posLocal3D.z, posLocal3D.y)

        var velLocal = velocity.applyQuaternion(this.qConjugate).setComponent(0,0) // ignore x

        while (posLocal2D.distanceTo( this.points[this.index] ) < this.lookAheadDistance ) {
            this.index = (this.index + 1) % this.N
        }

        var target = this.points[this.index]
        var tw = new THREE.Vector3(75, target.y, target.x).applyQuaternion(this.quaternion)

        this.box.position.set(tw.x, tw.y, tw.z)

        currentHeading = Math.atan2(velLocal.z, velLocal.y)
        var vectorToTarget = this.points[this.index].clone().sub(posLocal2D)
        angleToPoint = Math.atan2(vectorToTarget.x, vectorToTarget.y)

        angleError = ((currentHeading - angleToPoint) * 180 / Math.PI) % 360
        if (angleError < -180) angleError += 360
        if (angleError > 180) angleError -= 360

        var deltaAngle = Math.min( Math.max(-angleError/8, -12), 12) - 8

        if (this.on) {
          this.rudder.setRotationFromEuler( new THREE.Euler(0, - Math.PI / 2, deltaAngle/180 * Math.PI ), 'XYZ')
        }
      }

      toggle() {
        this.on = !this.on
      }

      setUpListener() {
        var self = this
        document.addEventListener('keydown',function(e) {
           var key = e.keyCode || e.which;
           if(key === 81) {
              self.toggle()
           }
        }, false);
      }
    }



    // Constants
    const rho = 1.205
    const wind = new THREE.Vector3( 5, 0, 0)
    const gravity = new THREE.Vector3( 0, -9.82, 0)

    var teProp = {
      segments : 10,
      totalLength : 70,
      kiteTLength : 3, // meter
      density : 950,
      diameter : 0.002,
      k0 : 2000, // spring konstant // N per e,
      k0_negative : 0, // spring konstant // N per e,
      d0 : 1, // damping,
      cd : 0.95,
    }

    var kite2 = new Kite(kiProp)
    scene.add(kite2.obj)


    var kite = new Kite(kiProp)
    kite.obj.add(new THREE.AxisHelper(5))
    kite.obj.rotateX(Math.PI / 2 )

    // kite
    var dx = Math.sqrt(teProp.kiteTLength*teProp.kiteTLength-kite.tetherAttachmentPoint1.y*kite.tetherAttachmentPoint1.y)
    kite.obj.position.add( new THREE.Vector3(teProp.totalLength + dx, 0, 0) )
    scene.add(kite.obj)

    var mTether = new Tether(kite)

    var pf = new PathFollow(0, 25, 20, 40, kite.rudder)


    function detectUserInput(dt) {
      // var a = THREE.Vector3(0, 0, -thrustRate * dt)
      // user input
      if (Key.isDown(Key.UP)) kite.elevator.rotateZ(-rotationRate * dt)
      if (Key.isDown(Key.LEFT)) kite.rudder.rotateZ(-rotationRate * dt)
      // if (Key.isDown(Key.DOWN)) kite.obj.rotateY(rotationRate * dt)
      if (Key.isDown(Key.DOWN)) kite.elevator.rotateZ(rotationRate * dt)
      if (Key.isDown(Key.RIGHT)) kite.rudder.rotateZ(rotationRate * dt)
      if (Key.isDown(Key.S)) kite.obj.rotateZ(-rotationRate/4 * dt)
      if (Key.isDown(Key.X)) kite.obj.rotateZ(rotationRate/4 * dt)
      if (Key.isDown(Key.A)) thrust.add( new THREE.Vector3(0, 0, -thrustRate * dt) ).max(thrustMax).min(thrustMin)
      if (Key.isDown(Key.Z)) thrust.add( new THREE.Vector3(0, 0, thrustRate * dt) ).max(thrustMax).min(thrustMin)
    }


    var wingAero = new AeroSurface(kite.wing, kiProp.wing.area, false,
      function(v) { return new THREE.Vector3( v.z, 0, -v.x ) },
      function(v) { return new THREE.Vector3( v.x, 0,  v.z ) }
    )

    var vWingAero = new AeroSurface( kite.vWing, kiProp.vWing.area, false,
      function(v) { return new THREE.Vector3( 0, v.z, -v.y ) },
      function(v) { return new THREE.Vector3( 0, v.y,  v.z ) }
    )

    var elevatorAero = new RotatingAeroSurface( kite.elevator, kiProp.elevator.area, true, kite.elevatorPosition,
      function(v) { return new THREE.Vector3( v.z, 0, -v.x ) },
      function(v) { return new THREE.Vector3( v.x, 0,  v.z ) }
    )

    var rudderAero = new RotatingAeroSurface( kite.rudder, kiProp.rudder.area, true, kite.rudderPosition,
      function(v) { return new THREE.Vector3( 0, v.z, -v.y ) },
      function(v) { return new THREE.Vector3( 0, v.y,  v.z ) }
    )

    var apKiteWorld, tap1SpringForceKite, tap2SpringForceKite

    function updateKitePositionAndForces(dt, tether) {
      //
      // KITE AERODYNAMICS
      //

      var kiteTF = mTether.kiteTetherForces()

      apKiteWorld = wind.clone().sub(kite.velocity)
      var apKiteKite = apKiteWorld.clone().applyQuaternion(kite.obj.getWorldQuaternion().conjugate())
      var thrustWorld = thrust.clone().applyQuaternion(kite.obj.getWorldQuaternion())

      wingAero.update(apKiteWorld, apKiteKite)
      vWingAero.update(apKiteWorld, apKiteKite)

      elevatorAero.update(apKiteWorld, apKiteKite, kite.angularVelocity)
      rudderAero.update(apKiteWorld, apKiteKite, kite.angularVelocity)

      // Total aero forces
      var aeroForcesKite = wingAero.lift.clone()
        .add(wingAero.drag)
        .add(vWingAero.lift)
        .add(vWingAero.drag)
        .add(elevatorAero.totalAero)
        .add(rudderAero.totalAero)

      // moments and rotation of kite
      tap1SpringForceKite = kiteTF.spring1.clone().applyQuaternion( kite.obj.quaternion.clone().conjugate() )
      tap2SpringForceKite = kiteTF.spring2.clone().applyQuaternion( kite.obj.quaternion.clone().conjugate() )

      var momentsKite = kite.elevatorPosition.clone().cross(elevatorAero.totalAero)
        .add(kite.rudderPosition.clone().cross(rudderAero.totalAero))
        .add(kite.tetherAttachmentPoint1.clone().cross( tap1SpringForceKite ) )
        .add(kite.tetherAttachmentPoint2.clone().cross( tap2SpringForceKite ) )

      var angularAcceleration = momentsKite.clone().applyMatrix3(kite.Jinv)//.setComponent(0, 0).setComponent(1, 0)
      kite.angularVelocity.add(angularAcceleration.multiplyScalar(dt))

      kite.obj.rotateOnAxis( kite.angularVelocity.clone().normalize(), kite.angularVelocity.length() * dt )

      // tether plus kite forces
      var FKite = kiteTF.spring1.clone()
        .add( kiteTF.spring2 )
        .add( kiteTF.drag1 )
        .add( kiteTF.drag2 )
        .add( thrustWorld )
        .add( aeroForcesKite.clone().applyQuaternion(kite.obj.quaternion))

      // update kite tether and position
      var accelerationKite = FKite.divideScalar(kite.mass + mTether.mass[mTether.KIndex1] + mTether.mass[mTether.KIndex2]).add(gravity)
      kite.velocity.add(accelerationKite.multiplyScalar(dt))
      kite.obj.position.add(kite.velocity.clone().multiplyScalar(dt))
    }


    function update(dt) {

      dt = dt // realtime
      dt = Math.min(dt, 0.03) // max timestep of 0.05 seconds

      detectUserInput(dt)

      var subFrameIterations = 20

      for (var k = 0; k < subFrameIterations; k++) {

        mTether.updateTetherPositionAndForces(dt/subFrameIterations)
        updateKitePositionAndForces(dt/subFrameIterations)

        mTether.updateKiteTetherPosAndVelocity(kite)
      }

      pf.update(kite.obj.position.clone(), kite.velocity.clone())

      // UPDATE UI
      // Set the position of the boxes showing the tether.
      for (var i = 0; i <= mTether.indexEnd; i++) {
        mTether.renderObjects[i].position.set(mTether.pos[i].x, mTether.pos[i].y, mTether.pos[i].z)
      }

      // Extra UI updates

      // arrowHelperLift.setDirection( wingLift.clone().normalize() )
      // arrowHelperDrag.setDirection( wingDrag.clone().normalize() )
      // arrowHelperLiftSide.setDirection( vwingLift.clone().normalize() )
      // arrowHelperDragSide.setDirection( vwingDrag.clone().normalize() )
      //
      // arrowHelperDrag.setLength( wingDrag.length() )
      // arrowHelperLift.setLength( wingLift.length() )
      // arrowHelperDragSide.setLength( vwingDrag.length() )
      // arrowHelperLiftSide.setLength( vwingLift.length() )

      // arrowHelperElevator.setDirection( elevatorAero.totalAero.clone().normalize() )
      // arrowHelperElevator.setLength( elevatorAero.totalAero.length() )
      //
      // arrowHelperRudder.setDirection( rudderAero.totalAero.clone().normalize() )
      // arrowHelperRudder.setLength( rudderAero.totalAero.length() )
      // //
      // arrowHelperTAP1.setDirection( tap1SpringForceKite.clone().normalize() )
      // arrowHelperTAP1.setLength( tap1SpringForceKite.length() )
      //
      // arrowHelperTAP2.setDirection( tap2SpringForceKite.clone().normalize() )
      // arrowHelperTAP2.setLength( tap2SpringForceKite.length() )


      document.getElementById('info').innerHTML = "apparent wind speed : " + apKiteWorld.length()
      document.getElementById('info').innerHTML = "alfa wing: " + Math.round(wingAero.alfa * 180 / Math.PI) + "<br />"
      document.getElementById('info').innerHTML += "alfa vertical wing : " + Math.round(vWingAero.alfa * 180 / Math.PI) + "<br />"
      document.getElementById('info').innerHTML += "thrust: " + thrust.getComponent(2) + "<br />"
      document.getElementById('info').innerHTML += "velocity: " + kite.velocity.length(2) + "<br />"
      // document.getElementById('info').innerHTML += "spring1: " + FSpring[KTIndex1].x + "<br />"
      // document.getElementById('info').innerHTML += "spring2: " + FSpring[KTIndex2].x + "<br />"
      // document.getElementById('info').innerHTML += "tSegmentStretchVelocity: " + tSegmentStretchVelocity[1] + "<br />"
      var euler = new THREE.Euler(0,0,0, 'ZYX')
      euler.setFromQuaternion(kite.obj.quaternion, 'ZYX', false)

      document.getElementById('info').innerHTML += "x: " + euler.x + "<br />"
      document.getElementById('info').innerHTML += "y: " + euler.y + "<br />"
      document.getElementById('info').innerHTML += "z: " + euler.z + "<br />"

      var px = kite.obj.position.x, pz = kite.obj.position.y
      var b = Math.atan2(kite.obj.position.z, px) * 180 / Math.PI
      var z = Math.atan2(kite.obj.position.y, Math.sqrt(px*px + pz+pz) ) * 180 / Math.PI

      document.getElementById('info').innerHTML += "<br />"
      document.getElementById('info').innerHTML += "b: " + b + "<br />"
      document.getElementById('info').innerHTML += "z: " + z + "<br />"

      document.getElementById('info').innerHTML += "<br />"
      document.getElementById('info').innerHTML += "rudder: " + new THREE.Euler().setFromQuaternion(kite.rudder.quaternion, 'XYZ').x * 180/Math.PI + "<br />"
      document.getElementById('info').innerHTML += "angleError: " + Math.floor(angleError) + "<br />"
      document.getElementById('info').innerHTML += "angleToPoint: " + Math.floor(angleToPoint*180/Math.PI) + "<br />"
      document.getElementById('info').innerHTML += "currentHeading: " + Math.floor(currentHeading*180/Math.PI) + "<br />"




    }

    var lastTime, animFrame

    function render(ms) {
      // we get passed a timestamp in milliseconds
      // we use it to determine how much time has passed since the last call
      if (lastTime) {
        update((ms-lastTime)/1000) // call update and pass delta time in seconds
      }

      lastTime = ms
      animFrame = requestAnimationFrame(render)
      renderer.render( scene, camera );

    }

    render()
  </script>


</body>
</html>
